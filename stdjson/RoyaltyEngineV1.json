{"language":"Solidity","sources":{"contracts/IRoyaltyEngineV1.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Lookup engine interface\n */\ninterface IRoyaltyEngineV1 is IERC165 {\n    /**\n     * Get the royalty for a given token (address, id) and value amount.  Does not cache the bps/amounts.  Caches the spec for a given token address\n     *\n     * @param tokenAddress - The address of the token\n     * @param tokenId      - The id of the token\n     * @param value        - The value you wish to get the royalty of\n     *\n     * returns Two arrays of equal length, royalty recipients and the corresponding amount each recipient should get\n     */\n    function getRoyalty(address tokenAddress, uint256 tokenId, uint256 value)\n        external\n        returns (address payable[] memory recipients, uint256[] memory amounts);\n\n    /**\n     * View only version of getRoyalty\n     *\n     * @param tokenAddress - The address of the token\n     * @param tokenId      - The id of the token\n     * @param value        - The value you wish to get the royalty of\n     *\n     * returns Two arrays of equal length, royalty recipients and the corresponding amount each recipient should get\n     */\n    function getRoyaltyView(address tokenAddress, uint256 tokenId, uint256 value)\n        external\n        view\n        returns (address payable[] memory recipients, uint256[] memory amounts);\n}\n"},"contracts/IRoyaltyRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Royalty registry interface\n */\ninterface IRoyaltyRegistry is IERC165 {\n    event RoyaltyOverride(address owner, address tokenAddress, address royaltyAddress);\n\n    /**\n     * Override the location of where to look up royalty information for a given token contract.\n     * Allows for backwards compatibility and implementation of royalty logic for contracts that did not previously support them.\n     *\n     * @param tokenAddress    - The token address you wish to override\n     * @param royaltyAddress  - The royalty override address\n     */\n    function setRoyaltyLookupAddress(address tokenAddress, address royaltyAddress) external returns (bool);\n\n    /**\n     * Returns royalty address location.  Returns the tokenAddress by default, or the override if it exists\n     *\n     * @param tokenAddress    - The token address you are looking up the royalty for\n     */\n    function getRoyaltyLookupAddress(address tokenAddress) external view returns (address);\n\n    /**\n     * Returns the token address that an overrideAddress is set for.\n     * Note: will not be accurate if the override was created before this function was added.\n     *\n     * @param overrideAddress - The override address you are looking up the token for\n     */\n    function getOverrideLookupTokenAddress(address overrideAddress) external view returns (address);\n\n    /**\n     * Whether or not the message sender can override the royalty address for the given token address\n     *\n     * @param tokenAddress    - The token address you are looking up the royalty for\n     */\n    function overrideAllowed(address tokenAddress) external view returns (bool);\n}\n"},"contracts/RoyaltyEngineV1.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport { ERC165, IERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { AddressUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport { SuperRareContracts } from \"./libraries/SuperRareContracts.sol\";\n\nimport { IManifold } from \"./specs/IManifold.sol\";\nimport { IRaribleV1, IRaribleV2 } from \"./specs/IRarible.sol\";\nimport { IFoundation } from \"./specs/IFoundation.sol\";\nimport { ISuperRareRegistry } from \"./specs/ISuperRare.sol\";\nimport { IEIP2981 } from \"./specs/IEIP2981.sol\";\nimport { IZoraOverride } from \"./specs/IZoraOverride.sol\";\nimport { IArtBlocksOverride } from \"./specs/IArtBlocksOverride.sol\";\nimport { IKODAV2Override } from \"./specs/IKODAV2Override.sol\";\nimport { IRoyaltyEngineV1 } from \"./IRoyaltyEngineV1.sol\";\nimport { IRoyaltyRegistry } from \"./IRoyaltyRegistry.sol\";\nimport { IRoyaltySplitter, Recipient } from \"./overrides/IRoyaltySplitter.sol\";\nimport { IFallbackRegistry } from \"./overrides/IFallbackRegistry.sol\";\n/**\n * @dev Engine to lookup royalty configurations\n */\n\ncontract RoyaltyEngineV1 is ERC165, OwnableUpgradeable, IRoyaltyEngineV1 {\n    using AddressUpgradeable for address;\n\n    // Use int16 for specs to support future spec additions\n    // When we add a spec, we also decrement the NONE value\n    // Anything > NONE and <= NOT_CONFIGURED is considered not configured\n    int16 private constant NONE = -1;\n    int16 private constant NOT_CONFIGURED = 0;\n    int16 private constant MANIFOLD = 1;\n    int16 private constant RARIBLEV1 = 2;\n    int16 private constant RARIBLEV2 = 3;\n    int16 private constant FOUNDATION = 4;\n    int16 private constant EIP2981 = 5;\n    int16 private constant SUPERRARE = 6;\n    int16 private constant ZORA = 7;\n    int16 private constant ARTBLOCKS = 8;\n    int16 private constant KNOWNORIGINV2 = 9;\n    int16 private constant ROYALTY_SPLITTER = 10;\n    int16 private constant FALLBACK = type(int16).max;\n\n    mapping(address => int16) _specCache;\n\n    address public royaltyRegistry;\n    IFallbackRegistry public immutable FALLBACK_REGISTRY;\n\n    constructor(address fallbackRegistry) {\n        FALLBACK_REGISTRY = IFallbackRegistry(fallbackRegistry);\n    }\n\n    function initialize(address _initialOwner, address royaltyRegistry_) public initializer {\n        _transferOwnership(_initialOwner);\n        require(ERC165Checker.supportsInterface(royaltyRegistry_, type(IRoyaltyRegistry).interfaceId));\n        royaltyRegistry = royaltyRegistry_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override (ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IRoyaltyEngineV1).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Invalidate the cached spec (useful for situations where tooken royalty implementation changes to a different spec)\n     */\n    function invalidateCachedRoyaltySpec(address tokenAddress) public {\n        address royaltyAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(tokenAddress);\n        delete _specCache[royaltyAddress];\n    }\n\n    /**\n     * @dev View function to get the cached spec of a token\n     */\n    function getCachedRoyaltySpec(address tokenAddress) public view returns (int16) {\n        address royaltyAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(tokenAddress);\n        return _specCache[royaltyAddress];\n    }\n\n    /**\n     * @dev See {IRoyaltyEngineV1-getRoyalty}\n     */\n    function getRoyalty(address tokenAddress, uint256 tokenId, uint256 value)\n        public\n        override\n        returns (address payable[] memory recipients, uint256[] memory amounts)\n    {\n        // External call to limit gas\n        try this._getRoyaltyAndSpec{gas: 100000}(tokenAddress, tokenId, value) returns (\n            address payable[] memory _recipients,\n            uint256[] memory _amounts,\n            int16 spec,\n            address royaltyAddress,\n            bool addToCache\n        ) {\n            if (addToCache) _specCache[royaltyAddress] = spec;\n            return (_recipients, _amounts);\n        } catch {\n            revert(\"Invalid royalty amount\");\n        }\n    }\n\n    /**\n     * @dev See {IRoyaltyEngineV1-getRoyaltyView}.\n     */\n    function getRoyaltyView(address tokenAddress, uint256 tokenId, uint256 value)\n        public\n        view\n        override\n        returns (address payable[] memory recipients, uint256[] memory amounts)\n    {\n        // External call to limit gas\n        try this._getRoyaltyAndSpec{gas: 100000}(tokenAddress, tokenId, value) returns (\n            address payable[] memory _recipients, uint256[] memory _amounts, int16, address, bool\n        ) {\n            return (_recipients, _amounts);\n        } catch {\n            revert(\"Invalid royalty amount\");\n        }\n    }\n\n    /**\n     * @dev Get the royalty and royalty spec for a given token\n     *\n     * returns recipients array, amounts array, royalty spec, royalty address, whether or not to add to cache\n     */\n    function _getRoyaltyAndSpec(address tokenAddress, uint256 tokenId, uint256 value)\n        external\n        view\n        returns (\n            address payable[] memory recipients,\n            uint256[] memory amounts,\n            int16 spec,\n            address royaltyAddress,\n            bool addToCache\n        )\n    {\n        require(msg.sender == address(this), \"Only Engine\");\n\n        royaltyAddress = IRoyaltyRegistry(royaltyRegistry).getRoyaltyLookupAddress(tokenAddress);\n        spec = _specCache[royaltyAddress];\n\n        if (spec <= NOT_CONFIGURED && spec > NONE) {\n            // No spec configured yet, so we need to detect the spec\n            addToCache = true;\n\n            // SuperRare handling\n            if (tokenAddress == SuperRareContracts.SUPERRARE_V1 || tokenAddress == SuperRareContracts.SUPERRARE_V2) {\n                try ISuperRareRegistry(SuperRareContracts.SUPERRARE_REGISTRY).tokenCreator(tokenAddress, tokenId)\n                returns (address payable creator) {\n                    try ISuperRareRegistry(SuperRareContracts.SUPERRARE_REGISTRY).calculateRoyaltyFee(\n                        tokenAddress, tokenId, value\n                    ) returns (uint256 amount) {\n                        recipients = new address payable[](1);\n                        amounts = new uint256[](1);\n                        recipients[0] = creator;\n                        amounts[0] = amount;\n                        return (recipients, amounts, SUPERRARE, royaltyAddress, addToCache);\n                    } catch { }\n                } catch { }\n            }\n            try IEIP2981(royaltyAddress).royaltyInfo(tokenId, value) returns (address recipient, uint256 amount) {\n                require(amount < value, \"Invalid royalty amount\");\n                try IRoyaltySplitter(royaltyAddress).getRecipients() returns (Recipient[] memory splitRecipients) {\n                    recipients = new address payable[](splitRecipients.length);\n                    amounts = new uint256[](splitRecipients.length);\n                    uint256 sum = 0;\n                    uint256 splitRecipientsLength = splitRecipients.length;\n                    for (uint256 i = 0; i < splitRecipientsLength;) {\n                        Recipient memory splitRecipient = splitRecipients[i];\n                        recipients[i] = payable(splitRecipient.recipient);\n                        uint256 splitAmount = splitRecipient.bps * amount / 10000;\n                        amounts[i] = splitAmount;\n                        sum += splitAmount;\n                        unchecked {\n                            ++i;\n                        }\n                    }\n                    // sum can be less than amount, otherwise small-value listings can break\n                    require(sum <= amount, \"Invalid split\");\n\n                    return (recipients, amounts, ROYALTY_SPLITTER, royaltyAddress, addToCache);\n                } catch {\n                    // Supports EIP2981.  Return amounts\n                    recipients = new address payable[](1);\n                    amounts = new uint256[](1);\n                    recipients[0] = payable(recipient);\n                    amounts[0] = amount;\n                    return (recipients, amounts, EIP2981, royaltyAddress, addToCache);\n                }\n            } catch { }\n            try IManifold(royaltyAddress).getRoyalties(tokenId) returns (\n                address payable[] memory recipients_, uint256[] memory bps\n            ) {\n                // Supports manifold interface.  Compute amounts\n                require(recipients_.length == bps.length);\n                return (recipients_, _computeAmounts(value, bps), MANIFOLD, royaltyAddress, addToCache);\n            } catch { }\n            try IRaribleV2(royaltyAddress).getRaribleV2Royalties(tokenId) returns (IRaribleV2.Part[] memory royalties) {\n                // Supports rarible v2 interface. Compute amounts\n                recipients = new address payable[](royalties.length);\n                amounts = new uint256[](royalties.length);\n                uint256 totalAmount;\n                for (uint256 i = 0; i < royalties.length; i++) {\n                    recipients[i] = royalties[i].account;\n                    amounts[i] = value * royalties[i].value / 10000;\n                    totalAmount += amounts[i];\n                }\n                require(totalAmount < value, \"Invalid royalty amount\");\n                return (recipients, amounts, RARIBLEV2, royaltyAddress, addToCache);\n            } catch { }\n            try IRaribleV1(royaltyAddress).getFeeRecipients(tokenId) returns (address payable[] memory recipients_) {\n                // Supports rarible v1 interface. Compute amounts\n                recipients_ = IRaribleV1(royaltyAddress).getFeeRecipients(tokenId);\n                try IRaribleV1(royaltyAddress).getFeeBps(tokenId) returns (uint256[] memory bps) {\n                    require(recipients_.length == bps.length);\n                    return (recipients_, _computeAmounts(value, bps), RARIBLEV1, royaltyAddress, addToCache);\n                } catch { }\n            } catch { }\n            try IFoundation(royaltyAddress).getFees(tokenId) returns (\n                address payable[] memory recipients_, uint256[] memory bps\n            ) {\n                // Supports foundation interface.  Compute amounts\n                require(recipients_.length == bps.length);\n                return (recipients_, _computeAmounts(value, bps), FOUNDATION, royaltyAddress, addToCache);\n            } catch { }\n            try IZoraOverride(royaltyAddress).convertBidShares(tokenAddress, tokenId) returns (\n                address payable[] memory recipients_, uint256[] memory bps\n            ) {\n                // Support Zora override\n                require(recipients_.length == bps.length);\n                return (recipients_, _computeAmounts(value, bps), ZORA, royaltyAddress, addToCache);\n            } catch { }\n            try IArtBlocksOverride(royaltyAddress).getRoyalties(tokenAddress, tokenId) returns (\n                address payable[] memory recipients_, uint256[] memory bps\n            ) {\n                // Support Art Blocks override\n                require(recipients_.length == bps.length);\n                return (recipients_, _computeAmounts(value, bps), ARTBLOCKS, royaltyAddress, addToCache);\n            } catch { }\n            try IKODAV2Override(royaltyAddress).getKODAV2RoyaltyInfo(tokenAddress, tokenId, value) returns (\n                address payable[] memory _recipients, uint256[] memory _amounts\n            ) {\n                // Support KODA V2 override\n                require(_recipients.length == _amounts.length);\n                return (_recipients, _amounts, KNOWNORIGINV2, royaltyAddress, addToCache);\n            } catch { }\n\n            try FALLBACK_REGISTRY.getRecipients(tokenAddress) returns (Recipient[] memory _recipients) {\n                uint256 recipientsLength = _recipients.length;\n                if (recipientsLength > 0) {\n                    return _calculateFallback(_recipients, recipientsLength, value, royaltyAddress, addToCache);\n                }\n            } catch { }\n\n            // No supported royalties configured\n            return (recipients, amounts, NONE, royaltyAddress, addToCache);\n        } else {\n            // Spec exists, just execute the appropriate one\n            addToCache = false;\n            if (spec == NONE) {\n                return (recipients, amounts, spec, royaltyAddress, addToCache);\n            } else if (spec == FALLBACK) {\n                Recipient[] memory _recipients = FALLBACK_REGISTRY.getRecipients(tokenAddress);\n                return _calculateFallback(_recipients, _recipients.length, value, royaltyAddress, addToCache);\n            } else if (spec == MANIFOLD) {\n                // Manifold spec\n                uint256[] memory bps;\n                (recipients, bps) = IManifold(royaltyAddress).getRoyalties(tokenId);\n                require(recipients.length == bps.length);\n                return (recipients, _computeAmounts(value, bps), spec, royaltyAddress, addToCache);\n            } else if (spec == RARIBLEV2) {\n                // Rarible v2 spec\n                IRaribleV2.Part[] memory royalties;\n                royalties = IRaribleV2(royaltyAddress).getRaribleV2Royalties(tokenId);\n                recipients = new address payable[](royalties.length);\n                amounts = new uint256[](royalties.length);\n                uint256 totalAmount;\n                for (uint256 i = 0; i < royalties.length; i++) {\n                    recipients[i] = royalties[i].account;\n                    amounts[i] = value * royalties[i].value / 10000;\n                    totalAmount += amounts[i];\n                }\n                require(totalAmount < value, \"Invalid royalty amount\");\n                return (recipients, amounts, spec, royaltyAddress, addToCache);\n            } else if (spec == RARIBLEV1) {\n                // Rarible v1 spec\n                uint256[] memory bps;\n                recipients = IRaribleV1(royaltyAddress).getFeeRecipients(tokenId);\n                bps = IRaribleV1(royaltyAddress).getFeeBps(tokenId);\n                require(recipients.length == bps.length);\n                return (recipients, _computeAmounts(value, bps), spec, royaltyAddress, addToCache);\n            } else if (spec == FOUNDATION) {\n                // Foundation spec\n                uint256[] memory bps;\n                (recipients, bps) = IFoundation(royaltyAddress).getFees(tokenId);\n                require(recipients.length == bps.length);\n                return (recipients, _computeAmounts(value, bps), spec, royaltyAddress, addToCache);\n            } else if (spec == EIP2981 || spec == ROYALTY_SPLITTER) {\n                // EIP2981 spec\n                (address recipient, uint256 amount) = IEIP2981(royaltyAddress).royaltyInfo(tokenId, value);\n                require(amount < value, \"Invalid royalty amount\");\n                if (spec == ROYALTY_SPLITTER) {\n                    Recipient[] memory splitRecipients = IRoyaltySplitter(royaltyAddress).getRecipients();\n                    recipients = new address payable[](splitRecipients.length);\n                    amounts = new uint256[](splitRecipients.length);\n                    uint256 sum = 0;\n                    uint256 splitRecipientsLength = splitRecipients.length;\n                    for (uint256 i = 0; i < splitRecipientsLength;) {\n                        Recipient memory splitRecipient = splitRecipients[i];\n                        recipients[i] = payable(splitRecipient.recipient);\n                        uint256 splitAmount = splitRecipient.bps * amount / 10000;\n                        amounts[i] = splitAmount;\n                        sum += splitAmount;\n                        unchecked {\n                            ++i;\n                        }\n                    }\n                    // sum can be less than amount, otherwise small-value listings can break\n                    require(sum <= value, \"Invalid split\");\n\n                    return (recipients, amounts, ROYALTY_SPLITTER, royaltyAddress, addToCache);\n                }\n                recipients = new address payable[](1);\n                amounts = new uint256[](1);\n                recipients[0] = payable(recipient);\n                amounts[0] = amount;\n                return (recipients, amounts, spec, royaltyAddress, addToCache);\n            } else if (spec == SUPERRARE) {\n                // SUPERRARE spec\n                address payable creator =\n                    ISuperRareRegistry(SuperRareContracts.SUPERRARE_REGISTRY).tokenCreator(tokenAddress, tokenId);\n                uint256 amount = ISuperRareRegistry(SuperRareContracts.SUPERRARE_REGISTRY).calculateRoyaltyFee(\n                    tokenAddress, tokenId, value\n                );\n                recipients = new address payable[](1);\n                amounts = new uint256[](1);\n                recipients[0] = creator;\n                amounts[0] = amount;\n                return (recipients, amounts, spec, royaltyAddress, addToCache);\n            } else if (spec == ZORA) {\n                // Zora spec\n                uint256[] memory bps;\n                (recipients, bps) = IZoraOverride(royaltyAddress).convertBidShares(tokenAddress, tokenId);\n                require(recipients.length == bps.length);\n                return (recipients, _computeAmounts(value, bps), spec, royaltyAddress, addToCache);\n            } else if (spec == ARTBLOCKS) {\n                // Art Blocks spec\n                uint256[] memory bps;\n                (recipients, bps) = IArtBlocksOverride(royaltyAddress).getRoyalties(tokenAddress, tokenId);\n                require(recipients.length == bps.length);\n                return (recipients, _computeAmounts(value, bps), spec, royaltyAddress, addToCache);\n            } else if (spec == KNOWNORIGINV2) {\n                // KnownOrigin.io V2 spec (V3 falls under EIP2981)\n                (recipients, amounts) =\n                    IKODAV2Override(royaltyAddress).getKODAV2RoyaltyInfo(tokenAddress, tokenId, value);\n                require(recipients.length == amounts.length);\n                return (recipients, amounts, spec, royaltyAddress, addToCache);\n            }\n        }\n    }\n\n    function _calculateFallback(\n        Recipient[] memory _recipients,\n        uint256 recipientsLength,\n        uint256 value,\n        address royaltyAddress,\n        bool addToCache\n    )\n        internal\n        pure\n        returns (\n            address payable[] memory recipients,\n            uint256[] memory amounts,\n            int16 spec,\n            address _royaltyAddress,\n            bool _addToCache\n        )\n    {\n        recipients = new address payable[](recipientsLength);\n        amounts = new uint256[](recipientsLength);\n        uint256 totalAmount;\n        for (uint256 i = 0; i < recipientsLength;) {\n            Recipient memory recipient = _recipients[i];\n            recipients[i] = payable(recipient.recipient);\n            uint256 amount = value * recipient.bps / 10_000;\n            amounts[i] = amount;\n            totalAmount += amount;\n            unchecked {\n                ++i;\n            }\n        }\n        require(totalAmount < value, \"Invalid royalty amount\");\n        return (recipients, amounts, FALLBACK, royaltyAddress, addToCache);\n    }\n\n    /**\n     * Compute royalty amounts\n     */\n    function _computeAmounts(uint256 value, uint256[] memory bps) private pure returns (uint256[] memory amounts) {\n        amounts = new uint256[](bps.length);\n        uint256 totalAmount;\n        for (uint256 i = 0; i < bps.length; i++) {\n            amounts[i] = value * bps[i] / 10000;\n            totalAmount += amounts[i];\n        }\n        require(totalAmount < value, \"Invalid royalty amount\");\n        return amounts;\n    }\n}\n"},"contracts/libraries/SuperRareContracts.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary SuperRareContracts {\n    address public constant SUPERRARE_REGISTRY = 0x17B0C8564E53f22364A6C8de6F7ca5CE9BEa4e5D;\n    address public constant SUPERRARE_V1 = 0x41A322b28D0fF354040e2CbC676F0320d8c8850d;\n    address public constant SUPERRARE_V2 = 0xb932a70A57673d89f4acfFBE830E8ed7f75Fb9e0;\n}\n"},"contracts/overrides/IFallbackRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { Recipient } from \"./IRoyaltySplitter.sol\";\n\ninterface IFallbackRegistry {\n    /**\n     * @dev Get total recipients for token fees. Note that recipient bps is of gross amount, not share of fee amount,\n     *      ie, recipients' BPS will not sum to 10_000, but to the total fee BPS for an order.\n     */\n    function getRecipients(address tokenAddress) external view returns (Recipient[] memory);\n}\n"},"contracts/overrides/IRoyaltySplitter.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nstruct Recipient {\n    address payable recipient;\n    uint16 bps;\n}\n\ninterface IRoyaltySplitter is IERC165 {\n    /**\n     * @dev Set the splitter recipients. Total bps must total 10000.\n     */\n    function setRecipients(Recipient[] calldata recipients) external;\n\n    /**\n     * @dev Get the splitter recipients;\n     */\n    function getRecipients() external view returns (Recipient[] memory);\n}\n"},"contracts/specs/IArtBlocksOverride.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n *  Interface for an Art Blocks override\n */\ninterface IArtBlocksOverride {\n    /**\n     * @dev Get royalites of a token at a given tokenAddress.\n     *      Returns array of receivers and basisPoints.\n     *\n     *  bytes4(keccak256('getRoyalties(address,uint256)')) == 0x9ca7dc7a\n     *\n     *  => 0x9ca7dc7a = 0x9ca7dc7a\n     */\n    function getRoyalties(address tokenAddress, uint256 tokenId)\n        external\n        view\n        returns (address payable[] memory, uint256[] memory);\n}\n"},"contracts/specs/IEIP2981.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * EIP-2981\n */\ninterface IEIP2981 {\n    /**\n     * bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\n     *\n     * => 0x2a55205a = 0x2a55205a\n     */\n    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\n}\n"},"contracts/specs/IFoundation.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IFoundation {\n    /*\n     *  bytes4(keccak256('getFees(uint256)')) == 0xd5a06d4c\n     *\n     *  => 0xd5a06d4c = 0xd5a06d4c\n     */\n    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\n}\n\ninterface IFoundationTreasuryNode {\n    function getFoundationTreasury() external view returns (address payable);\n}\n\ninterface IFoundationTreasury {\n    function isAdmin(address account) external view returns (bool);\n}\n"},"contracts/specs/IKODAV2Override.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/// @author: knownorigin.io\n\npragma solidity ^0.8.0;\n\ninterface IKODAV2 {\n    function editionOfTokenId(uint256 _tokenId) external view returns (uint256 _editionNumber);\n\n    function artistCommission(uint256 _editionNumber)\n        external\n        view\n        returns (address _artistAccount, uint256 _artistCommission);\n\n    function editionOptionalCommission(uint256 _editionNumber)\n        external\n        view\n        returns (uint256 _rate, address _recipient);\n}\n\ninterface IKODAV2Override {\n    /// @notice Emitted when the royalties fee changes\n    event CreatorRoyaltiesFeeUpdated(uint256 _oldCreatorRoyaltiesFee, uint256 _newCreatorRoyaltiesFee);\n\n    /// @notice For the given KO NFT and token ID, return the addresses and the amounts to pay\n    function getKODAV2RoyaltyInfo(address _tokenAddress, uint256 _id, uint256 _amount)\n        external\n        view\n        returns (address payable[] memory, uint256[] memory);\n\n    /// @notice Allows the owner() to update the creator royalties\n    function updateCreatorRoyalties(uint256 _creatorRoyaltiesFee) external;\n}\n"},"contracts/specs/IManifold.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author: manifold.xyz\n\n/**\n * @dev Royalty interface for creator core classes\n */\ninterface IManifold {\n    /**\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\n     *\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\n     *\n     *  => 0xbb3bafd6 = 0xbb3bafd6\n     */\n    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\n}\n"},"contracts/specs/IRarible.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IRaribleV1 {\n    /*\n     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\n     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\n     *\n     * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\n     */\n    function getFeeBps(uint256 id) external view returns (uint256[] memory);\n    function getFeeRecipients(uint256 id) external view returns (address payable[] memory);\n}\n\ninterface IRaribleV2 {\n    /*\n     *  bytes4(keccak256('getRaribleV2Royalties(uint256)')) == 0xcad96cca\n     */\n    struct Part {\n        address payable account;\n        uint96 value;\n    }\n\n    function getRaribleV2Royalties(uint256 id) external view returns (Part[] memory);\n}\n"},"contracts/specs/ISuperRare.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface ISuperRareRegistry {\n    /**\n     * @dev Get the royalty fee percentage for a specific ERC721 contract.\n     * @param _contractAddress address ERC721Contract address.\n     * @param _tokenId uint256 token ID.\n     * @return uint8 wei royalty fee.\n     */\n    function getERC721TokenRoyaltyPercentage(address _contractAddress, uint256 _tokenId)\n        external\n        view\n        returns (uint8);\n\n    /**\n     * @dev Utililty function to calculate the royalty fee for a token.\n     * @param _contractAddress address ERC721Contract address.\n     * @param _tokenId uint256 token ID.\n     * @param _amount uint256 wei amount.\n     * @return uint256 wei fee.\n     */\n    function calculateRoyaltyFee(address _contractAddress, uint256 _tokenId, uint256 _amount)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Get the token creator which will receive royalties of the given token\n     * @param _contractAddress address ERC721Contract address.\n     * @param _tokenId uint256 token ID.\n     */\n    function tokenCreator(address _contractAddress, uint256 _tokenId) external view returns (address payable);\n}\n"},"contracts/specs/IZoraOverride.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * Paired down version of the Zora Market interface\n */\ninterface IZoraMarket {\n    struct ZoraDecimal {\n        uint256 value;\n    }\n\n    struct ZoraBidShares {\n        // % of sale value that goes to the _previous_ owner of the nft\n        ZoraDecimal prevOwner;\n        // % of sale value that goes to the original creator of the nft\n        ZoraDecimal creator;\n        // % of sale value that goes to the seller (current owner) of the nft\n        ZoraDecimal owner;\n    }\n\n    function bidSharesForToken(uint256 tokenId) external view returns (ZoraBidShares memory);\n}\n\n/**\n * Paired down version of the Zora Media interface\n */\ninterface IZoraMedia {\n    /**\n     * Auto-generated accessors of public variables\n     */\n    function marketContract() external view returns (address);\n    function previousTokenOwners(uint256 tokenId) external view returns (address);\n    function tokenCreators(uint256 tokenId) external view returns (address);\n\n    /**\n     * ERC721 function\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n}\n\n/**\n * Interface for a Zora media override\n */\ninterface IZoraOverride {\n    /**\n     * @dev Convert bid share configuration of a Zora Media token into an array of receivers and bps values\n     *      Does not support prevOwner and sell-on amounts as that is specific to Zora marketplace implementation\n     *      and requires updates on the Zora Media and Marketplace to update the sell-on amounts/previous owner values.\n     *      An off-Zora marketplace sale will break the sell-on functionality.\n     */\n    function convertBidShares(address media, uint256 tokenId)\n        external\n        view\n        returns (address payable[] memory, uint256[] memory);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165Checker.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"}},"settings":{"remappings":["@manifoldxyz/libraries-solidity/=lib/libraries-solidity/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","create2-helpers/=lib/create2-helpers/src/","create2-scripts/=lib/create2-helpers/script/","ds-test/=lib/forge-std/lib/ds-test/src/","forge-std/=lib/forge-std/src/","libraries-solidity/=lib/libraries-solidity/contracts/","openzeppelin-contracts/=lib/create2-helpers/lib/openzeppelin-contracts/"],"optimizer":{"enabled":true,"runs":1000000},"metadata":{"bytecodeHash":"none"},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"london","libraries":{}}}
